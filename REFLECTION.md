# Project Reflection

The most persistent difficulty in the project was getting the stack to cooperate with modern Python. The starter code depended on aioredis, which no longer plays nicely with Python 3.12, so every integration test detonated with a missing distutils module once the virtual environment spun up. That failure also broke the Docker-based GitHub Actions run, meaning no CI feedback and no deployable image. Replacing the library required more than a version bump: the async helpers, requirements file, and even error handling in authentication had to be rewritten to use the maintained redis asyncio client. After wrapping the import in a friendly RuntimeError and ensuring tests fell back gracefully when Redis was unavailable, the pipeline finally stabilized and the whole team could trust the automated checks again.

Another challenge was simply understanding the intended architecture—especially how the calculation endpoints, authentication flows, and database initialization were supposed to line up. The faculty’s walkthrough video was a game changer: it clearly explained the FastAPI lifecycles, why the integration suite spins up a real Uvicorn server, and how the Playwright tests expect the app to behave. With that blueprint in mind the rest of the tasks—resetting the database between tests, caching pip downloads in CI, and capturing the required screenshots—became straightforward execution work instead of guesswork. The video made the assignment feel guided rather than exploratory, which was incredibly helpful.w
